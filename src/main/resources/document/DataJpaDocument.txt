（PS:会简单了很多，具体要不要使用这种模式还是要看需求）

在实际开发过程中，对数据库的操作无非就“增删改查”。就最为普遍的单表操作而言，除了表和字段不同外，语句都是类似的，开发人员需要写大量类似而枯燥的语句来完成业务逻辑。

为了解决这些大量枯燥的数据操作语句，我们第一个想到的是使用ORM框架，比如：Hibernate。通过整合Hibernate之后，我们以操作Java实体的方式最终将数据改变映射到数据库表中。

为了解决抽象各个Java实体基本的“增删改查”操作，我们通常会以泛型的方式封装一个模板Dao来进行抽象简化，但是这样依然不是很方便，我们需要针对每个实体编写一个继承自泛型模板Dao的接口，
再编写该接口的实现。虽然一些基础的数据访问已经可以得到很好的复用，但是在代码结构上针对每个实体都会有一堆Dao的接口和实现。

由于模板Dao的实现，使得这些具体实体的Dao层已经变的非常“薄”，有一些具体实体的Dao实现可能完全就是对模板Dao的简单代理，并且往往这样的实现类可能会出现在很多实体上。
Spring-data-jpa的出现正可以让这样一个已经很“薄”的数据访问层变成只是一层接口的编写方式。
其中需要在application.properties文件中配置一个自动创建表结构的设置（如使用嵌入式数据库则不需要）
spring.jpa.properties.hibernate.hbm2ddl.auto是hibernate的配置属性，其主要作用是：自动创建、更新、验证数据库表结构。该参数的几种配置如下：

create：每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。
create-drop：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。
update：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据model类自动更新表结构，
	           即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。
validate：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。

涉及到的类：User(其中的注解要有，具体的每个注解理解要自行百度) UserRepository
测试类：DataJpaTest （后续的多数据源配置会导致该测试类运行报错，一个解决办法是将 UserRepository 类移动到 该类下的子包 primary或者second 包中，或者在PrimaryConfig类中修改basePackges路径中去掉primary）


多数据源配置：
数据源的配置沿用TemplatesDocuments(没看过的，建议先看下)中DataSourceConfig的实现
为了保证多数据源配置可用，需将每个数据配置的Repository存放在不同的包路径下，为了避免一个数据源下创建出的其它数据源的实体，要将entity分开存放，不然会在该数据源下面创建出无用的表

涉及到的类：DataSourceConfig PrimaryConfig SecondConfig PrimaryDataJpaEntity SecondDataJpaEntity PrimaryDataJpaRepository SecondDataJpaRepository
测试类：MutiDataJpaTest
